#include "expression_generator_full.hpp"

#include "../../util/rng.hpp"
#include "../../util/macro.hpp"
#include "../../expressions/unary.hpp"
#include "../../expressions/binary.hpp"

#include <cassert>
#include <random>

namespace qsr {

/*
* Note: Non-trainable constants (CONSTANT) are never generated by
        ExpressionGenerator. Expressions including such constants
        can be manually created, if needed.
*/

static thread_local std::discrete_distribution<> depth_one_distribution({
    0,  /*CONSTANT*/
    10, /*PARAMETER*/
    10, /*IDENTITY*/
});

static thread_local std::discrete_distribution<> depth_two_distribution({
    0,  /*CONSTANT*/
    0,  /*PARAMETER*/
    0,  /*IDENTITY*/
    10, /*ADDITION*/
    10, /*SUBTRACTION*/
    10, /*MULTIPLICATION*/
    10, /*DIVISION*/
    10, /*SINE*/
    10, /*COSINE*/
    10  /*EXPONENTIAL*/
});

Expression FullExpressionGenerator::generate(int remaining_depth) const noexcept {
    #define _RANDOM_EXPR_CALL(i) \
        generate(remaining_depth - 1)

    assert(remaining_depth > 0);

    if (remaining_depth == 1) {
        int operation = depth_one_distribution(thread_local_rng);
        switch (operation) {
            case IDENTITY:
                return Var(thread_local_rng() % nvars);
            case PARAMETER:
                return Parameter(thread_local_rng() % nweights);
        }
    } 
    else if (remaining_depth >= 2) {
        int operation = depth_two_distribution(thread_local_rng);
        switch (operation) {
            BINARY_OP_CASE(ADDITION, _RANDOM_EXPR_CALL, +);
            BINARY_OP_CASE(SUBTRACTION, _RANDOM_EXPR_CALL, -);
            BINARY_OP_CASE(MULTIPLICATION, _RANDOM_EXPR_CALL, *);
            BINARY_OP_CASE(DIVISION, _RANDOM_EXPR_CALL, /);
            UNARY_OP_CASE(SINE, _RANDOM_EXPR_CALL, Sin);
            UNARY_OP_CASE(COSINE, _RANDOM_EXPR_CALL, Cos);
            UNARY_OP_CASE(EXPONENTIAL, _RANDOM_EXPR_CALL, Exp);
        }
    }

    // Control must never reach here.
    fprintf(stderr, "ExpressionGenerator::generate Illegal state encountered.\n");
    abort();
}

Expression FullExpressionGenerator::generate() const noexcept {
    return generate(this->depth);
}

}