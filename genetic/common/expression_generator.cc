// SPDX-FileCopyrightText: 2025 DoÄŸu Kocatepe
// SPDX-License-Identifier: GPL-3.0-or-later

#include "expression_generator.hpp"

#include "../../util/rng.hpp"
#include "../../util/macro.hpp"
#include "../../expressions/unary.hpp"
#include "../../expressions/binary.hpp"

#include <cassert>
#include <random>

namespace qsr {

/*
 * Note: Non-trainable constants (CONSTANT) are never generated by
         ExpressionGenerator. Expressions including such constants
         can be manually created, if needed.
 */

static thread_local std::discrete_distribution<> depth_one_distribution({
    0,  /*CONSTANT*/
    10, /*PARAMETER*/
    10, /*IDENTITY*/
});

static thread_local std::discrete_distribution<> depth_two_distribution({
    0,  /*CONSTANT*/
    10, /*PARAMETER*/
    10, /*IDENTITY*/
    10, /*ADDITION*/
    10, /*SUBTRACTION*/
    10, /*MULTIPLICATION*/
    10, /*DIVISION*/
    10, /*SINE*/
    10, /*COSINE*/
    10,  /*EXPONENTIAL*/
    10  /*RELU*/
});

int ExpressionGenerator::random_operation(int max_depth) const noexcept 
{
    // If the requested max depth is one, the only possible operations
    // are the ones that create leaf nodes: variables and weights.
    if (max_depth == 1) 
    {
        return depth_one_distribution(thread_local_rng);
    }

    // Otherwise, it is possible to add at least two to current depth.
    // Both binary and unary operations can be chosen.
    else if (max_depth >= 2) 
    {
        return depth_two_distribution(thread_local_rng);
    }

    // It is a bug if an operation with zero or negative depth is requested.
    else 
    {
        fprintf(stderr, "ExpressionGenerator::random_operation Illegal state encountered.\n");
        abort();
    }
}

Expression ExpressionGenerator::generate(int max_depth) const noexcept {
    int operation = random_operation(max_depth);

    #define _RANDOM_EXPR_CALL(i) \
        generate(max_depth - 1)

    switch (operation) {
        case IDENTITY:
            return Var(thread_local_rng() % nvars);
        case PARAMETER:
            return Parameter(thread_local_rng() % nweights);

        BINARY_OP_CASE(ADDITION, _RANDOM_EXPR_CALL, +);
        BINARY_OP_CASE(SUBTRACTION, _RANDOM_EXPR_CALL, -);
        BINARY_OP_CASE(MULTIPLICATION, _RANDOM_EXPR_CALL, *);
        BINARY_OP_CASE(DIVISION, _RANDOM_EXPR_CALL, /);
        UNARY_OP_CASE(SINE, _RANDOM_EXPR_CALL, Sin);
        UNARY_OP_CASE(COSINE, _RANDOM_EXPR_CALL, Cos);
        UNARY_OP_CASE(EXPONENTIAL, _RANDOM_EXPR_CALL, Exp);
        UNARY_OP_CASE(RECTIFIED_LINEAR_UNIT, _RANDOM_EXPR_CALL, ReLU);
    }

    // Control must never reach here.
    fprintf(stderr, "ExpressionGenerator::generate Illegal state encountered.\n");
    abort();
}

Expression ExpressionGenerator::generate() const noexcept {
    return generate(this->max_depth);
}

}